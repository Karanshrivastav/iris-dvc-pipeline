---
name: CD - Build & Deploy to GKE

on:
  push:
    branches: ["main"]

env:
  IMAGE_NAME: "iris-api"
  IMAGE_REPO_REGION: ${{ secrets.GCP_REGION }}
  PROJECT_ID: ${{ secrets.GCP_PROJECT }}
  ARTIFACT_REPO: ${{ secrets.ARTIFACT_REGISTRY_REPOSITORY }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install basic tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_DEPLOY_SA_KEY }}

      - name: Configure gcloud project
        run: |
          gcloud config set project $PROJECT_ID
          gcloud config set compute/region $IMAGE_REPO_REGION

      - name: Install gcloud components & kubectl
        run: |
          gcloud --version || (curl -sSL https://sdk.cloud.google.com | bash > /dev/null)
          gcloud components install kubectl --quiet || true
          gcloud components install alpha --quiet || true
          gcloud components install beta --quiet || true
          kubectl version --client

      - name: Setup Docker auth to Artifact Registry
        run: |
          gcloud auth configure-docker ${IMAGE_REPO_REGION}-docker.pkg.dev --quiet

      - name: Install DVC
        run: |
          python -m pip install --upgrade pip
          pip install dvc[gcs]
          pip install dvc-gs

      - name: Show GCP credentials file
        run: |
          echo "GOOGLE_APPLICATION_CREDENTIALS=$GOOGLE_APPLICATION_CREDENTIALS"
          head -n 5 $GOOGLE_APPLICATION_CREDENTIALS

      - name: DVC pull (get model)
        run: |
          dvc pull --force
          
      - name: Build and push Docker image to Artifact Registry
        id: build_push
        env:
          TAG: ${{ github.sha }}
          REGION: ${{ secrets.GCP_REGION }}
          REPO: ${{ secrets.ARTIFACT_REGISTRY_REPOSITORY }}
          PROJECT: ${{ secrets.GCP_PROJECT }}
        run: |
          IMAGE_URI="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/${IMAGE_NAME}:${TAG}"
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_OUTPUT
          docker build -t ${IMAGE_URI} .
          docker push ${IMAGE_URI}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: ${{ secrets.GKE_CLUSTER_NAME }}
          location: ${{ secrets.GKE_CLUSTER_ZONE }}
          project_id: ${{ secrets.GCP_PROJECT }}

      - name: Replace image placeholder in k8s manifest
        run: |
          IMAGE_URI=${{ steps.build_push.outputs.IMAGE_URI }}
          mkdir -p k8s-deploy
          sed "s|REPLACE_IMAGE_PLACEHOLDER|${IMAGE_URI}|g" k8s/deployment.yaml > k8s-deploy/deployment.yaml
          cp k8s/service.yaml k8s-deploy/service.yaml
          ls -R k8s-deploy

      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f k8s-deploy/deployment.yaml
          kubectl apply -f k8s-deploy/service.yaml
          kubectl rollout status deployment/iris-api --timeout=120s || kubectl rollout status deployment/iris-api

      - name: Wait for LoadBalancer IP
        id: get_ip
        run: |
          echo "Waiting for LoadBalancer external IP..."
          for i in {1..30}; do
            IP=$(kubectl get svc iris-api-lb -o jsonpath="{.status.loadBalancer.ingress[0].ip}" 2>/dev/null)
            if [ -n "$IP" ]; then
              echo "EXTERNAL_IP=$IP" >> $GITHUB_OUTPUT
              echo "âœ… Found external IP: $IP"
              exit 0
            fi
            echo "â³ Not ready yet ($i/30), sleeping 10s..."
            sleep 10
          done
          echo "âŒ ERROR: External IP not assigned after waiting"
          exit 1

      - name: Apply Horizontal Pod Autoscaler (HPA)
        run: |
          kubectl apply -f k8s/hpa.yaml
          kubectl get hpa

      # --- Begin In-cluster wrk stress test ---
      - name: Run in-cluster wrk load test
        run: |
          echo "ðŸš€ Starting in-cluster wrk load test..."
          kubectl delete pod wrk-tester --ignore-not-found
          kubectl run wrk-tester --image=williamyeh/wrk --restart=Never --command -- /bin/sh -c "while true; do sleep 3600; done"
          echo "Waiting for wrk-tester pod to start..."
          kubectl wait --for=condition=Ready pod/wrk-tester --timeout=120s

          echo 'wrk.method="POST";wrk.headers["Content-Type"]="application/json";wrk.body="{\"instances\":[[5.1,3.5,1.4,0.2]]}"' > wrk_post.lua
          kubectl cp wrk_post.lua wrk-tester:/wrk_post.lua

          echo "ðŸ”¥ Running 1000 concurrency test inside cluster..."
          kubectl exec wrk-tester -- wrk -t4 -c1000 -d30s -s /wrk_post.lua http://iris-api-lb/predict 2>&1 | tee wrk-1000.txt || true

          echo "ðŸ”¥ Running 2000 concurrency test inside cluster..."
          kubectl exec wrk-tester -- wrk -t4 -c2000 -d30s -s /wrk_post.lua http://iris-api-lb/predict 2>&1 | tee wrk-2000.txt || true

          echo "Collecting pod status..."
          kubectl get pods -o wide > wrk-pods.txt || true
          kubectl top pods --no-headers >> wrk-pods.txt || true
          kubectl get hpa -o wide >> wrk-pods.txt || true

      - name: Upload wrk results as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: wrk-results
          path: |
            wrk-1000.txt
            wrk-2000.txt
            wrk-pods.txt
      # --- End In-cluster wrk stress test ---
